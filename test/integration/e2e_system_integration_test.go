package integration

import (
	"encoding/json"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/liv-format/liv/pkg/container"
	"github.com/liv-format/liv/pkg/core"
	"github.com/liv-format/liv/test/utils"
)

// TestCompleteWorkflowIntegration tests the complete LIV document workflow
func TestCompleteWorkflowIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping complete workflow integration test in short mode")
	}

	helper := utils.NewTestHelper(t)
	defer helper.Cleanup()

	t.Run("document_creation_to_viewing_workflow", func(t *testing.T) {
		// Test complete workflow: Create -> Build -> Validate -> View

		// Step 1: Create source content
		sourceDir := filepath.Join(helper.TempDir, "source")
		err := os.MkdirAll(sourceDir, 0755)
		require.NoError(t, err)

		// Create HTML content
		htmlContent := `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E2E Integration Test Document</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>End-to-End Integration Test</h1>
            <p class="subtitle">Testing complete LIV document workflow</p>
        </header>
        
        <main>
            <section class="content">
                <h2>Document Features</h2>
                <p>This document tests the complete integration of all LIV components:</p>
                <ul>
                    <li>HTML content rendering</li>
                    <li>CSS styling and animations</li>
                    <li>Asset management (images, fonts)</li>
                    <li>Interactive JavaScript components</li>
                    <li>WASM module integration</li>
                    <li>Security policy enforcement</li>
                </ul>
            </section>
            
            <section class="interactive">
                <h2>Interactive Elements</h2>
                <div id="chart-container">
                    <canvas id="test-chart" width="400" height="200"></canvas>
                </div>
                <button id="test-button" onclick="testInteraction()">Test Interaction</button>
                <div id="output"></div>
            </section>
            
            <section class="assets">
                <h2>Asset Integration</h2>
                <img src="assets/images/test-logo.png" alt="Test Logo" class="logo">
                <p class="custom-font">This text uses a custom font asset.</p>
            </section>
        </main>
        
        <footer>
            <p>Generated by LIV E2E Integration Test</p>
        </footer>
    </div>
    
    <script src="scripts/main.js"></script>
</body>
</html>`

		err = ioutil.WriteFile(filepath.Join(sourceDir, "index.html"), []byte(htmlContent), 0644)
		require.NoError(t, err)

		// Create CSS content
		cssContent := `/* E2E Integration Test Styles */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    font-family: 'CustomFont', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    line-height: 1.6;
    color: #333;
}

header {
    text-align: center;
    margin-bottom: 40px;
    padding: 30px 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 10px;
    animation: fadeInDown 1s ease-out;
}

@keyframes fadeInDown {
    from {
        opacity: 0;
        transform: translateY(-30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

h1 {
    margin: 0;
    font-size: 2.5em;
    font-weight: 300;
}

.subtitle {
    margin: 10px 0 0 0;
    font-size: 1.2em;
    opacity: 0.9;
}

section {
    margin-bottom: 40px;
    padding: 30px;
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    animation: fadeInUp 0.8s ease-out;
}

@keyframes fadeInUp {
    from {
        opacity: 0;
        transform: translateY(30px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

h2 {
    color: #667eea;
    border-bottom: 2px solid #667eea;
    padding-bottom: 10px;
    margin-bottom: 20px;
}

ul {
    list-style-type: none;
    padding: 0;
}

li {
    padding: 8px 0;
    padding-left: 20px;
    position: relative;
}

li::before {
    content: "✓";
    position: absolute;
    left: 0;
    color: #4CAF50;
    font-weight: bold;
}

.interactive {
    background: #f8f9fa;
}

#chart-container {
    margin: 20px 0;
    text-align: center;
}

#test-chart {
    border: 2px solid #ddd;
    border-radius: 4px;
    background: white;
}

#test-button {
    background: #667eea;
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: all 0.3s ease;
}

#test-button:hover {
    background: #5a67d8;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#output {
    margin-top: 20px;
    padding: 15px;
    background: #e8f5e8;
    border-radius: 4px;
    border-left: 4px solid #4CAF50;
    min-height: 20px;
}

.logo {
    max-width: 100px;
    height: auto;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.custom-font {
    font-family: 'CustomFont', serif;
    font-size: 1.2em;
    font-style: italic;
    color: #764ba2;
}

footer {
    text-align: center;
    padding: 20px;
    color: #666;
    border-top: 1px solid #eee;
    margin-top: 40px;
}

/* Responsive design */
@media (max-width: 768px) {
    .container {
        padding: 10px;
    }
    
    h1 {
        font-size: 2em;
    }
    
    section {
        padding: 20px;
    }
}

/* Animation for interactive elements */
.pulse {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.05);
    }
    100% {
        transform: scale(1);
    }
}`

		stylesDir := filepath.Join(sourceDir, "styles")
		err = os.MkdirAll(stylesDir, 0755)
		require.NoError(t, err)
		err = ioutil.WriteFile(filepath.Join(stylesDir, "main.css"), []byte(cssContent), 0644)
		require.NoError(t, err)

		// Create JavaScript content
		jsContent := `// E2E Integration Test JavaScript
console.log('LIV E2E Integration Test - JavaScript loaded');

// Test interaction function
function testInteraction() {
    const output = document.getElementById('output');
    const button = document.getElementById('test-button');
    
    // Add visual feedback
    button.classList.add('pulse');
    setTimeout(() => button.classList.remove('pulse'), 2000);
    
    // Update output
    const timestamp = new Date().toLocaleTimeString();
    output.innerHTML = '<strong>✓ Interaction Test Successful!</strong><br>' +
                      'Button clicked at: ' + timestamp + '<br>' +
                      'JavaScript integration working correctly.';
    
    // Test chart rendering if WASM is available
    if (window.wasmChartEngine) {
        renderTestChart();
    } else {
        renderFallbackChart();
    }
}

// Fallback chart rendering using Canvas API
function renderFallbackChart() {
    const canvas = document.getElementById('test-chart');
    const ctx = canvas.getContext('2d');
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw simple bar chart
    const data = [30, 60, 45, 80, 25];
    const labels = ['A', 'B', 'C', 'D', 'E'];
    const barWidth = 60;
    const barSpacing = 20;
    const maxHeight = 150;
    const maxValue = Math.max(...data);
    
    // Draw bars
    data.forEach((value, index) => {
        const x = 50 + index * (barWidth + barSpacing);
        const height = (value / maxValue) * maxHeight;
        const y = canvas.height - height - 30;
        
        // Draw bar
        ctx.fillStyle = '#667eea';
        ctx.fillRect(x, y, barWidth, height);
        
        // Draw label
        ctx.fillStyle = '#333';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(labels[index], x + barWidth/2, canvas.height - 10);
        
        // Draw value
        ctx.fillText(value.toString(), x + barWidth/2, y - 5);
    });
    
    // Draw title
    ctx.fillStyle = '#333';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Test Chart (Canvas Fallback)', canvas.width/2, 25);
}

// WASM chart rendering (if available)
function renderTestChart() {
    try {
        const chartData = {
            type: 'bar',
            data: [30, 60, 45, 80, 25],
            labels: ['A', 'B', 'C', 'D', 'E'],
            options: {
                title: 'Test Chart (WASM Rendered)',
                colors: ['#667eea', '#764ba2', '#f093fb', '#f5576c', '#4facfe']
            }
        };
        
        window.wasmChartEngine.render('test-chart', chartData);
    } catch (error) {
        console.warn('WASM chart rendering failed, falling back to Canvas:', error);
        renderFallbackChart();
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing E2E test features...');
    
    // Render initial chart
    renderFallbackChart();
    
    // Add some interactive animations
    const sections = document.querySelectorAll('section');
    sections.forEach((section, index) => {
        section.style.animationDelay = (index * 0.2) + 's';
    });
    
    // Test local storage (if allowed by security policy)
    try {
        localStorage.setItem('liv-e2e-test', 'success');
        const testValue = localStorage.getItem('liv-e2e-test');
        console.log('Local storage test:', testValue);
    } catch (error) {
        console.log('Local storage blocked by security policy (expected):', error.message);
    }
    
    // Test network access (should be blocked by security policy)
    try {
        fetch('https://httpbin.org/json')
            .then(response => response.json())
            .then(data => console.log('Network access allowed:', data))
            .catch(error => console.log('Network access blocked (expected):', error.message));
    } catch (error) {
        console.log('Network access blocked by security policy (expected):', error.message);
    }
});

// Export for potential WASM integration
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        testInteraction,
        renderTestChart,
        renderFallbackChart
    };
}`

		scriptsDir := filepath.Join(sourceDir, "scripts")
		err = os.MkdirAll(scriptsDir, 0755)
		require.NoError(t, err)
		err = ioutil.WriteFile(filepath.Join(scriptsDir, "main.js"), []byte(jsContent), 0644)
		require.NoError(t, err)

		// Create test assets
		assetsDir := filepath.Join(sourceDir, "assets")
		imagesDir := filepath.Join(assetsDir, "images")
		fontsDir := filepath.Join(assetsDir, "fonts")
		err = os.MkdirAll(imagesDir, 0755)
		require.NoError(t, err)
		err = os.MkdirAll(fontsDir, 0755)
		require.NoError(t, err)

		// Create fake PNG image (minimal PNG header)
		pngData := []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52}
		err = ioutil.WriteFile(filepath.Join(imagesDir, "test-logo.png"), pngData, 0644)
		require.NoError(t, err)

		// Create fake font file
		fontData := make([]byte, 1024)
		for i := range fontData {
			fontData[i] = byte(i % 256)
		}
		err = ioutil.WriteFile(filepath.Join(fontsDir, "CustomFont.woff2"), fontData, 0644)
		require.NoError(t, err)

		// Create WASM module (fake WASM binary)
		wasmData := []byte{0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00} // WASM magic + version
		wasmData = append(wasmData, make([]byte, 1016)...)                 // Pad to 1KB
		err = ioutil.WriteFile(filepath.Join(sourceDir, "chart-engine.wasm"), wasmData, 0644)
		require.NoError(t, err)

		// Step 2: Test CLI build process
		outputFile := filepath.Join(helper.TempDir, "e2e-test.liv")

		// Check if CLI tools are available
		cliPath := findCLITool()
		if cliPath != "" {
			t.Logf("Testing with CLI tool: %s", cliPath)

			// Build document using CLI
			buildCmd := exec.Command(cliPath, "build", "--source", sourceDir, "--output", outputFile)
			buildOutput, buildErr := buildCmd.CombinedOutput()

			t.Logf("CLI build output: %s", string(buildOutput))

			if buildErr != nil {
				t.Logf("CLI build failed (expected if CLI not built): %v", buildErr)
			} else {
				// Verify output file was created
				helper.AssertFileExists(outputFile)

				// Step 3: Test validation
				validateCmd := exec.Command(cliPath, "validate", outputFile)
				validateOutput, validateErr := validateCmd.CombinedOutput()

				t.Logf("CLI validation output: %s", string(validateOutput))

				if validateErr != nil {
					t.Logf("CLI validation failed: %v", validateErr)
				} else {
					assert.Contains(t, string(validateOutput), "valid", "Document should be valid")
				}

				// Step 4: Test viewer integration
				viewerCmd := exec.Command(cliPath, "view", outputFile, "--headless")
				viewerOutput, viewerErr := viewerCmd.CombinedOutput()

				t.Logf("CLI viewer output: %s", string(viewerOutput))

				if viewerErr != nil {
					t.Logf("CLI viewer failed (expected if viewer not built): %v", viewerErr)
				}
			}
		} else {
			t.Logf("CLI tools not available, testing with Go packages directly")

			// Step 2 (alternative): Build using Go packages directly
			cont := container.NewContainer(outputFile)

			// Add manifest
			m := &core.Manifest{
				Version: "1.0",
				Metadata: &core.DocumentMetadata{
					Title:       "E2E Integration Test Document",
					Author:      "Integration Tester",
					Description: "End-to-end integration test document",
					Version:     "1.0.0",
					Language:    "en",
					Created:     time.Now(),
					Modified:    time.Now(),
				},
				Resources: make(map[string]*core.Resource),
				Security: &core.SecurityPolicy{
					WASMPermissions: &core.WASMPermissions{
						MemoryLimit:     64 * 1024 * 1024, // 64MB
						AllowNetworking: false,
						AllowFileSystem: false,
						AllowedImports:  []string{"env"},
					},
					JSPermissions: &core.JSPermissions{
						ExecutionMode: "sandboxed",
						AllowedAPIs:   []string{"dom", "canvas"},
					},
					NetworkPolicy: &core.NetworkPolicy{},
					StoragePolicy: &core.StoragePolicy{},
				},
			}

			manifestData, err := json.Marshal(m)
			require.NoError(t, err)

			err = cont.AddFile("manifest.json", manifestData)
			require.NoError(t, err) // Add content files
			htmlData, _ := ioutil.ReadFile(filepath.Join(sourceDir, "index.html"))
			err = cont.AddFile("content/index.html", htmlData)
			require.NoError(t, err)

			cssData, _ := ioutil.ReadFile(filepath.Join(stylesDir, "main.css"))
			err = cont.AddFile("content/styles/main.css", cssData)
			require.NoError(t, err)

			jsData, _ := ioutil.ReadFile(filepath.Join(scriptsDir, "main.js"))
			err = cont.AddFile("content/scripts/main.js", jsData)
			require.NoError(t, err)

			// Add assets
			pngData, _ := ioutil.ReadFile(filepath.Join(imagesDir, "test-logo.png"))
			err = cont.AddFile("assets/images/test-logo.png", pngData)
			require.NoError(t, err)

			fontData, _ := ioutil.ReadFile(filepath.Join(fontsDir, "CustomFont.woff2"))
			err = cont.AddFile("assets/fonts/CustomFont.woff2", fontData)
			require.NoError(t, err)

			// Add WASM module
			wasmData, _ := ioutil.ReadFile(filepath.Join(sourceDir, "chart-engine.wasm"))
			err = cont.AddFile("chart-engine.wasm", wasmData)
			require.NoError(t, err)

			// Save container
			err = cont.Save()
			require.NoError(t, err)

			helper.AssertFileExists(outputFile)
		}

		// Step 5: Test document integrity
		if _, err := os.Stat(outputFile); err == nil {
			// Verify document can be opened and read
			readContainer, err := container.OpenContainer(outputFile)
			require.NoError(t, err)

			// Verify all expected files exist
			files, err := readContainer.ListFiles()
			require.NoError(t, err)

			expectedFiles := []string{
				"manifest.json",
				"content/index.html",
				"content/styles/main.css",
				"content/scripts/main.js",
				"assets/images/test-logo.png",
				"assets/fonts/CustomFont.woff2",
				"chart-engine.wasm",
			}

			for _, expectedFile := range expectedFiles {
				assert.Contains(t, files, expectedFile, "Expected file should exist: %s", expectedFile)
			}

			// Verify content integrity
			htmlContent, err := readContainer.ReadFile("content/index.html")
			require.NoError(t, err)
			assert.Contains(t, string(htmlContent), "End-to-End Integration Test", "HTML content should be preserved")

			cssContent, err := readContainer.ReadFile("content/styles/main.css")
			require.NoError(t, err)
			assert.Contains(t, string(cssContent), "E2E Integration Test Styles", "CSS content should be preserved")

			jsContent, err := readContainer.ReadFile("content/scripts/main.js")
			require.NoError(t, err)
			assert.Contains(t, string(jsContent), "testInteraction", "JavaScript content should be preserved")
		}

		t.Logf("✓ Complete workflow integration test passed")
	})
}

// TestDataConsistencyValidation tests data consistency across all system layers
func TestDataConsistencyValidation(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping data consistency validation test in short mode")
	}

	helper := utils.NewTestHelper(t)
	defer helper.Cleanup()

	t.Run("cross_layer_data_consistency", func(t *testing.T) {
		// Create test document with known data
		doc, cont, containerPath := helper.CreateComplexTestDocument()

		// Save the document
		err := cont.Save()
		require.NoError(t, err)

		// Test 1: Verify Go layer can read the data correctly
		readContainer, err := container.OpenContainer(containerPath)
		require.NoError(t, err)

		manifestData, err := readContainer.ReadFile("manifest.json")
		require.NoError(t, err)

		var m core.Manifest
		err = json.Unmarshal(manifestData, &m)
		require.NoError(t, err)

		// Verify metadata consistency
		assert.Equal(t, doc.GetMetadata().Title, m.Metadata.Title)
		assert.Equal(t, doc.GetMetadata().Author, m.Metadata.Author)

		// Test 2: Verify content consistency
		htmlData, err := readContainer.ReadFile("content/index.html")
		require.NoError(t, err)
		assert.Equal(t, doc.GetContent().HTML, string(htmlData))

		cssData, err := readContainer.ReadFile("assets/styles.css")
		require.NoError(t, err)
		assert.Equal(t, doc.GetContent().CSS, string(cssData))

		// Test 3: Verify asset integrity
		files, err := readContainer.ListFiles()
		require.NoError(t, err)

		assetFiles := []string{
			"assets/images/logo.png",
			"assets/fonts/font.woff2",
			"modules/chart.wasm",
		}

		for _, assetFile := range assetFiles {
			assert.Contains(t, files, assetFile, "Asset file should exist: %s", assetFile)

			// Verify asset data integrity
			assetData, err := readContainer.ReadFile(assetFile)
			require.NoError(t, err)
			assert.Greater(t, len(assetData), 0, "Asset should have data: %s", assetFile)
		}

		t.Logf("✓ Cross-layer data consistency test passed")
	})

	t.Run("validation_consistency", func(t *testing.T) {
		// Test that validation results are consistent across different validation methods

		// Create test documents with various validation scenarios
		testCases := []struct {
			name          string
			setupDocument func() (string, error)
			expectValid   bool
		}{
			{
				name: "valid_complete_document",
				setupDocument: func() (string, error) {
					doc, cont, path := helper.CreateComplexTestDocument()
					_ = doc // Use doc to avoid unused variable
					return path, cont.Save()
				},
				expectValid: true,
			},
			{
				name: "document_missing_manifest",
				setupDocument: func() (string, error) {
					containerPath := filepath.Join(helper.TempDir, "invalid-no-manifest.liv")
					cont := container.NewContainer(containerPath)

					// Add content but no manifest
					err := cont.AddFile("content/index.html", []byte("<html><body>Test</body></html>"))
					if err != nil {
						return "", err
					}

					return containerPath, cont.Save()
				},
				expectValid: false,
			},
		}

		for _, tc := range testCases {
			t.Run(tc.name, func(t *testing.T) {
				containerPath, err := tc.setupDocument()
				require.NoError(t, err)

				// Test validation using different methods

				// Method 1: Direct container validation
				if _, err := os.Stat(containerPath); err == nil {
					readContainer, err := container.OpenContainer(containerPath)
					if err != nil && tc.expectValid {
						t.Errorf("Expected valid document but failed to open: %v", err)
					} else if err == nil && !tc.expectValid {
						// Check if manifest exists for invalid case
						files, _ := readContainer.ListFiles()
						hasManifest := false
						for _, file := range files {
							if file == "manifest.json" {
								hasManifest = true
								break
							}
						}
						if !hasManifest && tc.name == "document_missing_manifest" {
							t.Logf("✓ Correctly detected missing manifest")
						}
					}
				}

				// Method 2: CLI validation (if available)
				cliPath := findCLITool()
				if cliPath != "" {
					validateCmd := exec.Command(cliPath, "validate", containerPath)
					validateOutput, validateErr := validateCmd.CombinedOutput()

					if tc.expectValid && validateErr != nil {
						t.Logf("CLI validation failed for valid document: %v, output: %s", validateErr, string(validateOutput))
					} else if !tc.expectValid && validateErr == nil {
						t.Logf("CLI validation passed for invalid document, output: %s", string(validateOutput))
					}
				}
			})
		}

		t.Logf("✓ Validation consistency test passed")
	})
}

// TestSecurityModelIntegration tests security model integration across all components
func TestSecurityModelIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping security model integration test in short mode")
	}

	helper := utils.NewTestHelper(t)
	defer helper.Cleanup()

	t.Run("security_policy_enforcement", func(t *testing.T) {
		// Create document with strict security policy
		containerPath := filepath.Join(helper.TempDir, "secure-test.liv")
		cont := container.NewContainer(containerPath)

		// Create restrictive security policy
		m := &core.Manifest{
			Version: "1.0",
			Metadata: &core.DocumentMetadata{
				Title:  "Security Test Document",
				Author: "Security Tester",
			},
			Security: &core.SecurityPolicy{
				WASMPermissions: &core.WASMPermissions{
					MemoryLimit:     16 * 1024 * 1024, // 16MB - restrictive
					AllowNetworking: false,
					AllowFileSystem: false,
					AllowedImports:  []string{"env"}, // Minimal imports
				},
				JSPermissions: &core.JSPermissions{
					ExecutionMode: "sandboxed",
					AllowedAPIs:   []string{"dom"}, // No canvas, no network
				},
			},
			Resources: make(map[string]*core.Resource),
		}

		manifestData, err := json.Marshal(m)
		require.NoError(t, err)

		err = cont.AddFile("manifest.json", manifestData)
		require.NoError(t, err)

		// Add content that should be restricted
		restrictedJS := `
// This JavaScript should be restricted by security policy
console.log('Testing security restrictions...');

// Attempt network access (should be blocked)
try {
    fetch('https://example.com/api/data')
        .then(response => response.json())
        .then(data => console.log('Network access succeeded:', data))
        .catch(error => console.log('Network access blocked:', error));
} catch (error) {
    console.log('Network access blocked by policy:', error);
}

// Attempt local storage access (should be blocked)
try {
    localStorage.setItem('test', 'value');
    console.log('Local storage access succeeded');
} catch (error) {
    console.log('Local storage access blocked:', error);
}

// Attempt canvas access (should be blocked based on policy)
try {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    if (ctx) {
        console.log('Canvas access succeeded');
    } else {
        console.log('Canvas access blocked');
    }
} catch (error) {
    console.log('Canvas access blocked:', error);
}
`

		err = cont.AddFile("content/scripts/restricted.js", []byte(restrictedJS))
		require.NoError(t, err)

		// Add HTML that references the restricted script
		restrictedHTML := `<!DOCTYPE html>
<html>
<head>
    <title>Security Test</title>
</head>
<body>
    <h1>Security Policy Test</h1>
    <p>This document tests security policy enforcement.</p>
    <div id="output"></div>
    <script src="scripts/restricted.js"></script>
</body>
</html>`

		err = cont.AddFile("content/index.html", []byte(restrictedHTML))
		require.NoError(t, err)

		// Add WASM module that exceeds memory limit
		largeWasmData := make([]byte, 32*1024*1024)                                     // 32MB - exceeds 16MB limit
		copy(largeWasmData[:8], []byte{0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00}) // WASM header

		err = cont.AddFile("large-module.wasm", largeWasmData)
		require.NoError(t, err)

		// Save container
		err = cont.Save()
		require.NoError(t, err)

		// Test security validation
		cliPath := findCLITool()
		if cliPath != "" {
			// Test with CLI security validation
			validateCmd := exec.Command(cliPath, "validate", "--security", containerPath)
			validateOutput, validateErr := validateCmd.CombinedOutput()

			t.Logf("Security validation output: %s", string(validateOutput))

			// Should detect security policy violations
			if validateErr == nil {
				// Check if output mentions security warnings
				outputStr := string(validateOutput)
				if !strings.Contains(outputStr, "security") && !strings.Contains(outputStr, "warning") {
					t.Logf("Security validation may not be detecting policy violations")
				}
			}
		}

		// Test that document can still be opened (security is enforced at runtime, not creation)
		readContainer, err := container.OpenContainer(containerPath)
		require.NoError(t, err)

		// Verify security policy is preserved
		manifestData, err = readContainer.ReadFile("manifest.json")
		require.NoError(t, err)

		var readManifest core.Manifest
		err = json.Unmarshal(manifestData, &readManifest)
		require.NoError(t, err)

		assert.Equal(t, int64(16*1024*1024), readManifest.Security.WASMPermissions.MemoryLimit)
		assert.False(t, readManifest.Security.WASMPermissions.AllowNetworking)
		assert.Equal(t, "sandboxed", readManifest.Security.JSPermissions.ExecutionMode)

		t.Logf("✓ Security policy enforcement test passed")
	})

	t.Run("signature_verification_integration", func(t *testing.T) {
		// Test digital signature integration

		// Generate test key pair
		privateKey, publicKey := helper.GenerateTestKeyPair()
		privateKeyPath, publicKeyPath := helper.SaveKeyPair(privateKey, publicKey)

		// Create document for signing
		containerPath := filepath.Join(helper.TempDir, "signed-test.liv")

		// Test CLI signing (if available)
		cliPath := findCLITool()
		if cliPath != "" {
			// Create source content
			sourceDir := filepath.Join(helper.TempDir, "sign-source")
			err := os.MkdirAll(sourceDir, 0755)
			require.NoError(t, err)

			htmlContent := "<html><body><h1>Signed Document Test</h1></body></html>"
			err = ioutil.WriteFile(filepath.Join(sourceDir, "index.html"), []byte(htmlContent), 0644)
			require.NoError(t, err)

			// Build and sign document
			buildCmd := exec.Command(cliPath, "build", "--source", sourceDir, "--output", containerPath, "--sign", "--key", privateKeyPath)
			buildOutput, buildErr := buildCmd.CombinedOutput()

			t.Logf("CLI build with signing output: %s", string(buildOutput))

			if buildErr != nil {
				t.Logf("CLI signing failed (expected if signing not implemented): %v", buildErr)
			} else {
				// Verify signature
				verifyCmd := exec.Command(cliPath, "verify", containerPath, "--key", publicKeyPath)
				verifyOutput, verifyErr := verifyCmd.CombinedOutput()

				t.Logf("CLI signature verification output: %s", string(verifyOutput))

				if verifyErr != nil {
					t.Logf("CLI signature verification failed: %v", verifyErr)
				} else {
					assert.Contains(t, string(verifyOutput), "valid", "Signature should be valid")
				}
			}
		} else {
			t.Logf("CLI tools not available, skipping signature integration test")
		}

		t.Logf("✓ Signature verification integration test passed")
	})
}

// TestGoRustJSLayerIntegration tests integration between Go, Rust WASM, and JS layers
func TestGoRustJSLayerIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping Go-Rust-JS layer integration test in short mode")
	}

	helper := utils.NewTestHelper(t)
	defer helper.Cleanup()

	t.Run("multi_layer_communication", func(t *testing.T) {
		// Test communication flow: Go -> WASM -> JS -> Go

		// Create document with WASM and JS components
		containerPath := filepath.Join(helper.TempDir, "multi-layer-test.liv")
		cont := container.NewContainer(containerPath)

		// Add manifest with WASM configuration
		m := &core.Manifest{
			Version: "1.0",
			Metadata: &core.DocumentMetadata{
				Title:  "Multi-Layer Integration Test",
				Author: "Integration Tester",
			},
			WASMConfig: &core.WASMConfiguration{
				Modules: map[string]*core.WASMModule{
					"integration-test": {
						Name:       "integration-test",
						Version:    "1.0",
						EntryPoint: "main",
						Exports:    []string{"process_data", "get_result"},
						Imports:    []string{"env"},
						Permissions: &core.WASMPermissions{
							MemoryLimit:     32 * 1024 * 1024,
							AllowNetworking: false,
							AllowFileSystem: false,
							AllowedImports:  []string{"env"},
						},
					},
				},
				Permissions: &core.WASMPermissions{
					MemoryLimit:     64 * 1024 * 1024,
					AllowNetworking: false,
					AllowFileSystem: false,
					AllowedImports:  []string{"env"},
				},
			},
			Resources: make(map[string]*core.Resource),
		}

		manifestData, err := json.Marshal(m)
		require.NoError(t, err)

		err = cont.AddFile("manifest.json", manifestData)
		require.NoError(t, err) // Add JavaScript that communicates with WASM
		jsContent := `
// Multi-layer integration test JavaScript
console.log('Multi-layer integration test starting...');

class IntegrationTest {
    constructor() {
        this.wasmModule = null;
        this.testResults = [];
    }
    
    async initializeWASM() {
        try {
            // Load WASM module
            const wasmResponse = await fetch('integration-test.wasm');
            const wasmBytes = await wasmResponse.arrayBuffer();
            
            // Instantiate WASM module
            const wasmModule = await WebAssembly.instantiate(wasmBytes, {
                env: {
                    // Provide environment functions for WASM
                    log: (ptr, len) => {
                        // Read string from WASM memory
                        const memory = wasmModule.instance.exports.memory;
                        const buffer = new Uint8Array(memory.buffer, ptr, len);
                        const message = new TextDecoder().decode(buffer);
                        console.log('WASM Log:', message);
                        this.testResults.push({type: 'wasm_log', message});
                    },
                    report_result: (result) => {
                        console.log('WASM Result:', result);
                        this.testResults.push({type: 'wasm_result', value: result});
                    }
                }
            });
            
            this.wasmModule = wasmModule.instance;
            console.log('WASM module loaded successfully');
            return true;
        } catch (error) {
            console.error('WASM loading failed:', error);
            this.testResults.push({type: 'error', message: 'WASM loading failed: ' + error.message});
            return false;
        }
    }
    
    runIntegrationTest() {
        if (!this.wasmModule) {
            console.log('WASM module not available, running JS-only test');
            this.runJSOnlyTest();
            return;
        }
        
        try {
            // Test WASM function calls
            if (this.wasmModule.exports.process_data) {
                const testData = 42;
                const result = this.wasmModule.exports.process_data(testData);
                console.log('WASM process_data result:', result);
                this.testResults.push({type: 'wasm_call', input: testData, output: result});
            }
            
            if (this.wasmModule.exports.get_result) {
                const finalResult = this.wasmModule.exports.get_result();
                console.log('WASM get_result:', finalResult);
                this.testResults.push({type: 'wasm_final', value: finalResult});
            }
            
            // Test memory sharing
            if (this.wasmModule.exports.memory) {
                const memory = new Uint8Array(this.wasmModule.exports.memory.buffer);
                console.log('WASM memory size:', memory.length);
                this.testResults.push({type: 'memory_test', size: memory.length});
            }
            
        } catch (error) {
            console.error('WASM integration test failed:', error);
            this.testResults.push({type: 'error', message: 'WASM test failed: ' + error.message});
        }
    }
    
    runJSOnlyTest() {
        // Fallback test when WASM is not available
        console.log('Running JavaScript-only integration test');
        
        const testData = [1, 2, 3, 4, 5];
        const processedData = testData.map(x => x * 2);
        const sum = processedData.reduce((a, b) => a + b, 0);
        
        this.testResults.push({type: 'js_processing', input: testData, output: processedData, sum});
        
        // Simulate async operation
        setTimeout(() => {
            this.testResults.push({type: 'js_async', message: 'Async operation completed'});
            this.displayResults();
        }, 100);
    }
    
    displayResults() {
        const output = document.getElementById('integration-output');
        if (output) {
            let html = '<h3>Integration Test Results:</h3><ul>';
            this.testResults.forEach(result => {
                html += '<li><strong>' + result.type + ':</strong> ' + JSON.stringify(result) + '</li>';
            });
            html += '</ul>';
            output.innerHTML = html;
        }
        
        // Report results to Go layer (if available)
        if (window.goIntegrationCallback) {
            window.goIntegrationCallback(this.testResults);
        }
    }
    
    async run() {
        console.log('Starting multi-layer integration test...');
        
        const wasmLoaded = await this.initializeWASM();
        this.runIntegrationTest();
        
        if (!wasmLoaded) {
            this.displayResults();
        }
        
        console.log('Multi-layer integration test completed');
    }
}

// Initialize test when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
    const test = new IntegrationTest();
    await test.run();
});

// Export for testing
if (typeof module !== 'undefined' && module.exports) {
    module.exports = IntegrationTest;
}
`

		err = cont.AddFile("content/scripts/integration-test.js", []byte(jsContent))
		require.NoError(t, err)

		// Add HTML that loads the integration test
		htmlContent := `<!DOCTYPE html>
<html>
<head>
    <title>Multi-Layer Integration Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #integration-output { 
            background: #f5f5f5; 
            padding: 15px; 
            border-radius: 5px; 
            margin-top: 20px; 
        }
    </style>
</head>
<body>
    <h1>Multi-Layer Integration Test</h1>
    <p>Testing communication between Go, Rust WASM, and JavaScript layers.</p>
    <div id="integration-output">
        <p>Running integration test...</p>
    </div>
    <script src="scripts/integration-test.js"></script>
</body>
</html>`

		err = cont.AddFile("content/index.html", []byte(htmlContent))
		require.NoError(t, err)

		// Add mock WASM module
		wasmData := []byte{0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00} // WASM magic + version
		wasmData = append(wasmData, make([]byte, 2040)...)                 // Pad to 2KB

		err = cont.AddFile("integration-test.wasm", wasmData)
		require.NoError(t, err)

		// Save container
		err = cont.Save()
		require.NoError(t, err)

		// Verify document structure
		readContainer, err := container.OpenContainer(containerPath)
		require.NoError(t, err)

		files, err := readContainer.ListFiles()
		require.NoError(t, err)

		expectedFiles := []string{
			"manifest.json",
			"content/index.html",
			"content/scripts/integration-test.js",
			"integration-test.wasm",
		}

		for _, expectedFile := range expectedFiles {
			assert.Contains(t, files, expectedFile, "Expected file should exist: %s", expectedFile)
		}

		// Verify WASM configuration in manifest
		manifestData, err = readContainer.ReadFile("manifest.json")
		require.NoError(t, err)

		var readManifest core.Manifest
		err = json.Unmarshal(manifestData, &readManifest)
		require.NoError(t, err)

		assert.NotNil(t, readManifest.WASMConfig, "WASM configuration should be present")
		assert.Contains(t, readManifest.WASMConfig.Modules, "integration-test", "WASM module should be configured")

		t.Logf("✓ Multi-layer communication test passed")
	})
}

// Helper function to find CLI tool
func findCLITool() string {
	possiblePaths := []string{
		"../bin/liv-cli",
		"../bin/liv-cli.exe",
		"../../bin/liv-cli",
		"../../bin/liv-cli.exe",
		"liv-cli",
		"liv-cli.exe",
	}

	for _, path := range possiblePaths {
		if _, err := os.Stat(path); err == nil {
			return path
		}
		if _, err := exec.LookPath(path); err == nil {
			return path
		}
	}

	return ""
}
